import sublime, sublime_plugin
import subprocess
import os
import html
import json
import webbrowser
from pprint import pprint

# Notes:
# - -Zno-trans produces a warning about being unstable (see
#   https://github.com/rust-lang/rust/issues/31847). I am uncertain about the
#   long-term prospects of how this will be resolved.  There are a few things
#   to consider:
#       - Cargo recently added "cargo check"
#         (https://github.com/rust-lang/cargo/pull/3296), which more or less
#         does the same thing.  See also the original "cargo check" addon
#         (https://github.com/rsolomo/cargo-check/).
#       - RLS was recently released
#         (https://github.com/rust-lang-nursery/rls).  It's unclear to me if
#         this will perform full-linting that could replace this or not.
#
# - -Zno-trans prevents some warnings and errors from being generated. For
#   example, see const-err.rs.  "cargo check" will solve this, but it is
#   nightly only right now. Other issues:
#       - Errors generated by compiling lib when compiling the bin target do
#         not output as json.
#
# - Code in a normal module annotated with #[test] will never be checked.  I
#   do not know of a way to tell rustc to compile that the same way "cargo
#   test" does.

# TODO:
# - clippy support (doesn't output json afaik)
# - Some way to navigate to messages?  Similar to Build next/previous.

class rustPluginSyntaxCheckEvent(sublime_plugin.EventListener):

    # Beware: This gets called multiple times if the same buffer is opened in
    # multiple views (with the same view passed in each time).  See:
    # https://github.com/SublimeTextIssues/Core/issues/289
    def on_post_save_async(self, view):
        # Are we in rust scope and is it switched on?
        # We use phantoms which were added in 3118
        if int(sublime.version()) < 3118:
            return

        settings = view.settings()
        enabled = settings.get('rust_syntax_checking')
        if enabled and "source.rust" in view.scope_name(0):
            file_name = os.path.abspath(view.file_name())
            file_dir = os.path.dirname(file_name)
            os.chdir(file_dir)

            view.set_status('rust-check', 'Rust syntax check running...')
            try:
                self.hide_phantoms(view.window())

                # Keep track of regions used for highlighting, since Sublime
                # requires it to be added in one shot.
                # Key is view.id, value is
                #     {'view': view, 'regions': [(scope, region)]}
                regions_by_view = {}

                for target_src, infos in self.get_rustc_messages(settings, file_name):
                    # print('-------------')
                    for info in infos:
                        # pprint(info)
                        self.add_error_phantom(view.window(), info, settings, regions_by_view, target_src, {})

                self.draw_region_highlights(regions_by_view)
            finally:
                view.erase_status('rust-check')

        # If the user has switched OFF the plugin, remove any phantom lines
        elif not enabled:
            self.hide_phantoms(view.window())
        # print('done')

    def run_cargo(self, args):
        """Args should be an array of arguments for cargo.
        Returns list of dictionaries of the parsed JSON output.
        """
        # shell=True is needed to stop the window popping up, although it looks like this is needed:
        # http://stackoverflow.com/questions/3390762/how-do-i-eliminate-windows-consoles-from-spawned-processes-in-python-2-7
        cmd = ' '.join(['cargo']+args)
        print('Running %r' % cmd)
        cproc = subprocess.Popen(cmd,
            shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
        output = cproc.communicate()
        output = output[0].decode('utf-8')  # ignore errors?
        result = []
        for line in output.split('\n'):
            if line == '' or line[0] != '{':
                continue
            result.append(json.loads(line))
        # print(output)
        if not result and cproc.returncode:
            print('Failed to run: %s' % cmd)
            print(output)
        return result

    def get_rustc_messages(self, settings, file_name):
        targets = self.determine_targets(settings, file_name)
        for (target_src, target_args) in targets:
            yield (target_src, self.run_cargo(['rustc', target_args,
                '--', '-Zno-trans', '-Zunstable-options', '--error-format=json']))

    def determine_targets(self, settings, file_name):
        """Detect the target/filters needed to pass to rustc to compile
        file_name.
        Returns list of (target_src_path, target_command_line_args) tuples.
        """
        # First check config for manual targets.
        for project in settings.get('projects', {}).values():
            src_root = os.path.join(project.get('root', ''), 'src')
            if not file_name.startswith(src_root):
                continue
            targets = project.get('targets', {})
            for tfile, tcmd in targets.items():
                if file_name == os.path.join(src_root, tfile):
                    return [(tfile, tcmd)]
            else:
                target = targets.get('_default', '')
                if target:
                    # Unfortunately don't have the target src filename.
                    return [('', target)]

        # Try a heuristic to detect the filename.
        output = self.run_cargo(['metadata', '--no-deps'])
        if not output:
            return []
        # TODO: This is broken for crates using the "workspace" feature.  Each
        # sub-crate appears as a separate entry in "packages".  This needs
        # logic to match file_name with the appropriate sub-crate, which may
        # not be straightforward.
        targets = output[0]['packages'][0]['targets']
        for target in targets:
            # XXX: In what situations can a target have multiple "kinds"?
            kind = target['kind'][0]
            if target['src_path'] == file_name:
                if kind == 'lib':
                    return [(target['src_path'], '--lib')]
                else:
                    # bin, test, example, bench
                    return [(target['src_path'], '--'+kind+' '+target['name'])]
        # No filename match, run all targets.
        # TODO: Perhaps abort if the list is too large?
        if len(targets) > 10:
            print('Warning: Rust detected a large number of targets!')
        result = []
        for target in targets:
            kind = target['kind'][0]
            if kind == 'lib':
                result.append((target['src_path'], '--lib'))
            else:
                # bin, test, example, bench
                result.append((target['src_path'],
                    '--'+kind+' '+target['name']))
        return result


    def hide_phantoms(self, window):
        for view in window.views():
            view.erase_phantoms('buildErrorLine')
            view.erase_regions('rust-invalid')
            view.erase_regions('rust-info')

    def add_error_phantom(self, window, info, settings, regions_by_view, target_src_path, parent_info):
        error_colour = settings.get('rust_syntax_error_color', 'var(--redish)')
        warning_colour = settings.get('rust_syntax_warning_color', 'var(--yellowish)')

        # TODO: Consider matching the colors used by rustc.
        # - error: red
        #     `bug` appears as "error: internal compiler error"
        # - warning: yellow
        # - note: bright green
        # - help: cyan
        is_error = info['level'] == 'error'
        if is_error:
            base_color = error_colour
        else:
            base_color = warning_colour

        msg_template = """
            <body id="rust-message">
                <style>
                    span {{
                        font-family: monospace;
                    }}
                    .rust-error {{
                        color: %s;
                    }}
                    .rust-additional {{
                        color: var(--yellowish);
                    }}
                    a {{
                        text-decoration: inherit;
                        padding: 0.35rem 0.5rem 0.45rem 0.5rem;
                        position: relative;
                        font-weight: bold;
                    }}
                </style>
                <span class="{cls}">{level}: {msg} {extra}<a href="hide">\xD7</a></span>
            </body>""" % (base_color,)

        def click_handler(url):
            if url == 'hide':
                self.hide_phantoms(window)
            else:
                webbrowser.open_new(url)

        def add_message(view, region, message, extra=''):
            vid = view.id()
            if vid not in regions_by_view:
                regions_by_view[vid] = {'view': view, 'regions': {}}
            # Unfortunately you cannot specify colors, but instead scopes as
            # defined in the color theme.  If the scope is not defined, then
            # it will show up as foreground color.  I just use "info" as an
            # undefined scope (empty string will remove regions).
            scope = 'invalid' if is_error else 'info'
            regions_by_view[vid]['regions'].setdefault(scope, []).append(region)

            # For some reason, with LAYOUT_BELOW, if you have a multi-line
            # region, the phantom is only displayed under the first line.  I
            # think it makes more sense for the phantom to appear below the
            # last line.
            start = view.rowcol(region.begin())
            end = view.rowcol(region.end())
            if start[0] != end[0]:
                # Spans multiple lines, adjust to the last line.
                region = sublime.Region(
                    view.text_point(end[0], 0),
                    region.end()
                )

            if info['level'] == 'error':
                cls = 'rust-error'
            else:
                cls = 'rust-additional'

            # Rust performs some pretty-printing for things like suggestions,
            # attempt to retain some of the formatting.  This isn't perfect
            # (doesn't line up perfectly), not sure why.
            message = html.escape(message, quote=False).\
                replace('\n', '<br>').replace(' ', '&nbsp;')
            content = msg_template.format(
                cls = cls,
                level = info['level'],
                msg = message,
                extra = extra
            )
            view.add_phantom(
                'buildErrorLine', region,
                content,
                sublime.LAYOUT_BELOW,
                click_handler
            )

        def add_primary_message(view, region, message):
            parent_info['view'] = view
            parent_info['region'] = region
            if info['code']:
                # TODO
                # This could potentially be a link that opens a Sublime popup, or
                # a new temp buffer with the contents of 'explanation'.
                # (maybe use sublime-markdown-popups)
                extra = ' <a href="https://doc.rust-lang.org/error-index.html#%s">?</a>' % (info['code']['code'],)
            else:
                extra = ''
            add_message(view, region, message, extra)

        def report_silent_message(path, message):
            print('rust: %s' % path)
            print('[%s]: %s' % (info['level'], message))

        if len(info['spans']) == 0:
            if parent_info:
                # This is extra info attached to the parent message.
                add_primary_message(parent_info['view'],
                                    parent_info['region'],
                                    info['message'])
            else:
                # Messages without spans are global session messages (like "main
                # function not found"). The most appropriate place for most of the
                # messages is the root path (like main.rs).
                #
                # Some of the messages are not very interesting, though.
                imsg = info['message']
                if not (imsg.startswith('aborting due to') or
                        imsg.startswith('cannot continue')):
                    view = window.find_open_file(os.path.realpath(target_src_path))
                    if view:
                        # Place at bottom of file for lack of anywhere better.
                        r = sublime.Region(view.size())
                        add_primary_message(view, r, imsg)
                    else:
                        report_silent_message(target_src_path, imsg)

        for span in info['spans']:
            is_primary = span['is_primary']
            if 'macros>' in span['file_name']:
                # Rust gives the chain of expansions for the macro, which we
                # don't really care about.  We want to find the site where the
                # macro was invoked.
                def find_span_r(span):
                    if 'macros>' in span['file_name']:
                        if span['expansion']:
                            return find_span_r(span['expansion']['span'])
                        else:
                            # XXX: Is this possible?
                            return None
                    else:
                        return span
                span = find_span_r(span)
                if span == None:
                    continue
            view = window.find_open_file(os.path.realpath(span['file_name']))
            if view:
                # Sublime text is 0 based whilst the line/column info from
                # rust is 1 based.
                region = sublime.Region(
                    view.text_point(span['line_start'] - 1, span['column_start'] - 1),
                    view.text_point(span['line_end'] - 1, span['column_end'] - 1)
                )

                label = span['label']
                if label:
                    # Display the label for this Span.
                    add_message(view, region, label)
                else:
                    # Some spans don't have a label.  These seem to just imply
                    # that the main "message" is sufficient, and always seems
                    # to happen with the span is_primary.
                    if not is_primary:
                        # When can this happen?
                        pprint(info)
                        raise ValueError('Unexpected span with no label')
                if is_primary:
                    # Show the overall error message.
                    add_primary_message(view, region, info['message'])
                if span['suggested_replacement']:
                    # The "suggested_replacement" contains the code that
                    # should replace the span.  However, it can be easier to
                    # read if you repeat the entire line (from "rendered").
                    add_message(view, region, info['rendered'])
            else:
                # File is currently not open.
                if is_primary:
                    report_silent_message(span['file_name'], info['message'])
                if span['label']:
                    report_silent_message(span['file_name'], span['label'])

        # Recurse into children (which typically hold notes).
        for child in info['children']:
            self.add_error_phantom(window, child, settings, regions_by_view, target_src_path, parent_info)

    def draw_region_highlights(self, regions_by_view):
        for d in regions_by_view.values():
            view = d['view']
            for scope, regions in d['regions'].items():
                # Is DRAW_EMPTY necessary?  Is it possible to have a zero-length span?
                view.add_regions('rust-%s' % scope, regions, scope, '',
                    sublime.DRAW_NO_FILL|sublime.DRAW_EMPTY)
